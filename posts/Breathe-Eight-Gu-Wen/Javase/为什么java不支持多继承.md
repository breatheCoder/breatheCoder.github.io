- [x] 为什么java不支持多继承  [completion:: 2025-08-12]

## 典型回答

因为如果要实现多继承的话, 就会像C++一样, 出现菱形继承的问题, C++为了解决菱形继承的问题, 又引入了虚继承. 因为支持多继承, 引入了菱形继承的问题, 又因为要解决菱形继承的问题, 引入虚继承. 而经过分析, 人们发现我们其实真正想要使用多继承的情况并不多, 所以在java中, 不允许"多继承", 即一个类不允许继承多个父类.

除了菱形的问题, 支持多继承复杂度也会增加. 一个类继承了多个父类,可能会继承大量的属性和方法, 导致累的接口变得庞大, 难以理解和维护. 此外, 在修改一个父类时,可能会影响到多个子类, 增加了代码的耦合度.

在JDK8之前, 接口中是不能有方法实现的, 所以一个类同时实现多个接口的话, 也不会出现c++中的起义问题, 因为所有方法都没有方法体, 真正的实现还是在子类中的, 但是, JDK8中支持默认函数(default method), 即接口中可以定义一个有方法体的方法.

而又因为java支持同时实现多个接口, 这就相当于通过implements 就可以从多个接口中继承到多个方法了, 但是, JDK8为了避免菱形继承的问题, 在实现的接口中如果有相同的方法, 就会要求该类必须重写这个方法.

## 扩展知识

### 菱形继承问题

java的创始人詹姆斯高斯林曾经说过:

	java之所有不支持一个类继承多个类, 主要是因为在设计之初我们听取了来自c++和Objective-c阵营的人的意见, 因为多继承会出现很多歧义问题.

这个歧义问题其实就是菱形继承问题.

加入我们有类B和类C,他们都继承了相同的类A，另外我们还有类D，　类D通过多重继承机制继承了类B和类C．

![[Pasted image 20250812181208.png]]
这时候, 因为D同时继承了B和C, 并且B和C又同时继承了A, 那么, D中就会因为多重继承,集成到两份来自A中的属性和方法.

这时候在使用D的时候,如果想要调用一个定义在A中的方法的时候，就会出现歧义．

因为这样的继承关系的形状类似于菱形，所以被称为菱形继承问题．

而c++为了解决菱形继承问题, 又引入了虚继承.

因为支持多继承, 引入了菱形继承问题, 又因为解决菱形继承问题, 引入了虚继承. 而经过分析, 人们发现真正需要使用多继承的场景并不多.

所以在java中,不允许"声明多继承", 即一个类不允许继承多个父类, 但是java允许实现多实现, 即一个类可以实现多个接口, 一个接口也可以继承多个父接口. 由于接口只允许有方法声明而不允许有方法实现(jdk8才出现的default), 这就避免了c++中的多继承的歧义问题.

### java8的多实现

Java不支持多继承, 但是是支持多实现的, 也就是说同一个类可以同时实现多个接口.

我们知道,在jdk8以前,接口是不能有方法的实现的, 所以一个类同时实现多个接口的话, 也不会有c++的歧义问题, 因为所有方法都没有方法体, 真正的实现还是子类中的.

那么问题来了.

jdk8中支持了默认函数, 即接口中可以定义有方法体的方法了.

```java
public interface Pet {
	public default void eat() {
		system.out.println("Pet Is Eating");
	}
}
```

而又因为java支持同时实现多个接口,这就相当于通过implements就可以从多个接口中继承多个方法了, 这不就是变相支持了多继承吗.

那么, java是如何解决菱形继承问题的呢? 我们再定义一个哺乳动物接口, 也定义一个eat方法

```java
public interface Mammal {
	public default void eat() {
		System.out.println("Mammal Is Eating");
	}
}
```

然后定义一个Cat,让他分别实现两个接口:

```java
public class Cat implements Pet, Mammal {

}
```

这时候编译会报错, 要求Cat类中必须重写eat方法.

所以可以看到, java并没有帮我们解决多继承的歧义问题, 而是把这个问题留给开发人员, 通过重写方法的方式自己解决.
