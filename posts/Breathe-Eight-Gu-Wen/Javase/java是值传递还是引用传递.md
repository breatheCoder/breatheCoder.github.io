- [x] java是值传递还是引用传递  [completion:: 2025-08-12]

## 典型回答

编程语言中需要进行方法间的参数传递, 这个传递策略叫做求值策略.

在程序设计中, 求值策略有很多, 比较常见的就是 **值传递** 和 **引用传递**.

值传递和引用传递的最大区别就是在传递的过程中有没有复制一个副本出来, 如果是传递副本, 那就是值传递, 否则就是引用传递.

java对象的传递, 是通过复制的方式把引用关系传递了, 因为有复制的过程, 所以是值传递, 只不过java对象的传递, 传递的内容是对象的引用.

## 扩展知识

### java的求值策略

我们说当进行方法求值的时候, 需要把实际的参数, 传递给形式参数, 那么传递的过程中到底传递的是什么东西呢?

这其实是程序设计中求值策略的概念.

在计算机科学中, 求值策略是确定编程语言中表达式的求职的一组(通常确定性)规则. 求值策略定义何时以何种方式给函数实际的参数, 什么时候把他们带入函数, 和代换以何种形式发生.

求值策略分为两大基本类, 基于如何处理给函数的实际参数, 分为严格的和非严格的.

#### 严格求值

在 **严格求值** 中, 函数调用的过程中, 给函数的实际参数总是在应用这个函数之前求值, 多数现存编程语言对函数都使用严格求值.

在严格求值中有几个关键的求值策略是我们关心的, 那就是 **传值调用** , **传引用调用**, 以及 **传共享对象调用** .

- 传值调用(值传递)
	- 在传值调用中, 实际参数先被求值, 然后其值通过复制, 被传递给被调函数的形参, 因为形参拿到的是一个 **局部拷贝** , 所以如果在被调函数中改变了形式参数的值, 并不会改变实际参数的值. 
- 传引用调用(引用传递)
	- 在传引用调用中, 传递给函数的是他的实际参数的隐式引用而不是实参的copy, 因为传递的是引用, 所以, 如果在被调函数中改变了形式参数的值, 改变对于调用者来说是可见的. 
- 传共享对象调用(共享对象传递)
	- 传共享对象调用中, 先获取到实际参数的地址, 然后将其复制, 并把该地址的copy传递给被调函数, 因为参数的地址都指向同一个对象, 所以我们也称为传共享对象, 所以, 如果是在被调函数中改变了形式参数的值, 调用者是可以看到这种变化的.

不知道大家有没有发现, 其实传共享对象调用和传值调用的过程基本上是一样的, 都是进行 "求值", "拷贝", "传递". 

其实传共享对象调用和传引用调用是一样的, 都是在被调函数中改变参数的值, 参数会有感知. 

那么, 共享对象调用和值传递以及引用传递到底什么关系呢?

对于这个问题, 我们应该关注过程, 而不是结果, 因为传共享对象调用的过程和传值调用的过程是一样的, 而且都有一步关键的操作, 那就是 "复制" , 所以, 通常我们认为传共享对象调用是传值调用的特例.

前面我们介绍了传值调用, 传引用调用 和 传共享对象调用, 那么Java是采用哪种求值策略呢

很多人说java的基本数据类型是值传递的, 这个没什么讨论的, 就是这样. 

但是很多人却认为java中的对象传递是引用传递, 之所以会有这个误区, 主要是因为java中的变量和对象之间是有引用关系的, java是通过对象的引用来操作对象的, 所以很多人认为对象的传递其实是引用的传递. 

而且很多人都举出以下代码举例

```java
public class Test {
	public static void main(String[] args) {
		Test pt = new Test();
		User breathe = new User();
		breathe.setName("breathe");
		breathe.setGender("Male");
		pt.pass(breathe);
		System.out.println("print in main, user is " + breathe);
	}
	public void pass(User user) {
		user.setName("breatheMAX");
		System.out.println("print in pass, user is " + breathe);
	}
}
```

输出发现名字确实改变了, 就说是引用传递.

但是这其实是走进了一个误区.

### java中的对象传递

很多人通过代码示例的现象说明java对象是引用传递, 那么我们就从现象入手, 先反驳以下这个观点.

我们前面说过, 无论是值传递, 还是引用传递, 只不过是求值策略的一种, 那求值策略还有很多, 比如之前提到的传共享对象传递, 凭什么说是引用传递, 不是共享对象传递?

那么, java中的对象传递到底是哪种形式, 其实还真是共享对象传递.

在java官方文档中写过:

	原始参数通过值传递方法, 这意味着对参数值的任何修改都只存在于方法的范围内, 当方法返回时, 参数将消失, 对他们的任何修改都将消失.

	引用数据类型参数也按值传递给方法, 这意味着当方法返回的时候, 传入的引用仍然引用之前的对象, 但是如果对象字段具有适当的访问级别, 则可以在方法中更改这些字段的值.

官方的回答就是java是值传递, 只不过把对象的引用当值传递给方法而已, 这难道就不是共享对象传递吗?

其实java中使用的求值策略就是共享对象传递, 也就是说, java会将对象的地址给copy传递给被调的函数. 只不过传共享对象调用这个词并不常用, 所以java社区的人通常说java是传值调用, 这么说也没错, 因为传共享对象调用就是传值调用的一个特例.

### 值传递和共享对象传递的现象冲突吗?

看到这里肯定有人会疑惑, 既然共享对象传递是值传递的一个特例, 那么为什么他们的现象是完全不同的.

难道值传递的时候, 如果在被调方法中改变了值, 也有可能对被传递者造成影响吗, 其实是不冲突的.

真正的对象是存在堆区上的, 我们在方法中传递的时候,通常不会将真正的对象传递过去, 而是传递一个对象的引用, 可以类比该对象的地址, 你虽然改变了他的字段的值, 但是并没有改变他的地址, 所以其实还是没有改变. 他这里的值指的不是对象的字段的值, 而是对象的地址.

我们可以回到上面的例子, 画个图给大家看看发生了什么?

[[java值传递还是引用传递的例子]]

在参数传递的过程中，实际参数的地址0x123456被copy给了形参， 这个过程其实就是值传递, 不过传递的值的内容是对象的引用.

那么为什么我们改了user中的属性的值, 却对原来的user产生了影响呢?
因为操作对象的话, 也是根据引用来操作的

这个过程就好像是:

	你复制了一把家里的要是给你的朋友, 他拿到钥匙以后, 并没有在这把要是上做任何改动,而是通过要是打开了你家的房门, 进到屋里,把你家的电视给砸了.

也就是说, java对象的传递, 是通过复制的方式把引用关系传递了, 如果我们没有改引用关系, 而是找到引用的地址, 是会对调用方有影响的, 因为大家指向的是同一个共享对象.

那么如果我们改动以下pass方法的内容:

```java
public void pass(User user) {
	user = new User();
	user.setName("breatheMAX");
	usermsetGender("Male");
	System.out.println("print in pass, user is " + user);
}
```

这个函数变成这样的话, 就不会改变我们原先的值, 而是重新在堆区创建了一个.

所以java中的对象传递,如果是修改引用, 是不会对原来的对象有任何影响的, 但是如果直接修改共享对象的属性的值, 是会对原来的对象有影响的.

### 总结

我们知道,编程语言中需要进行方法间的参数传递, 这个传递策略叫做求值策略.

在程序设计中, 求值策略有很多种, 比较常见的是值传递和引用传递. 还有一种值传递的特例--共享对象传递

值传递和引用传递最大的区别就是在传递的过程中有没有copy一个副本来, 如果是传递副本, 就是值传递, 否则就是引用传递.

在java中, 其实是通过值传递实现的参数传递, 只不过对于java对象的传递, 传递的内容是对象的引用.

我们可以总结说,java中的求值策略是共享对象传递, 这是完全正确的.

但是为了让大家都能理解, 我们可以说java中只有值传递, 只不过传递的内容是对象的引用.

这也是没毛病的.

但是绝对不能认为java中有引用传递.